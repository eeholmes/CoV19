---
title: "Forecasts version 3"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
```

```{r, message=FALSE, warning=FALSE, include=FALSE}
library(CoV19)
library(ggplot2)
library(gridExtra)
```

These are forecast by fitting a log-normal shape curve the new positive cases and estimating deaths using the 7-lag CFR.  The 95% confidence intervals on the forecasts are shown. 

These are just toy forecasts to try to understand the behavior of statistical forecasts using only a log-normal fit to new cases.  This is somewhat similar to the strategy used in the [UW model](https://covid19.healthdata.org/) except they fit to deaths and I am fitting to a 3-day average of reported positives.

These are just experiments to understand the nature of these kind of fits.  Don't put any stock whatsoever into these 'forecasts'. One thing I've noticed is that, the fitting algorithm seems to like to put the peak at the end of the data. Perhaps that is true or perhaps this approach is biased that way. I am fitting a lognormal curve and that is a very specific curve shape. That curve may be imposing too much 'information' when there is no real information in the data about the location of the peak.

```{r thenormfuncs}
# estimate mu, sigma and scaling
  f2<-function(x, theta) {
    m<-theta[1]; s<-theta[2]; a<-theta[3];
    a*exp(-0.5*((x-m)/s)^2)
  }
  f2<-function(x, theta) {
    m<-theta[1]; s<-theta[2]; a<-theta[3];
    a*exp(-0.5*((x-m)/s)^2)
  }
# fix m
  f3<-function(x, theta, m) {
    s<-theta[1]; a<-theta[2];
    a*exp(-0.5*((x-m)/s)^2)
  }
# fix s
  f4<-function(x, theta, s) {
    m<-theta[1]; a<-theta[2];
    a*exp(-0.5*((x-m)/s)^2)
  }
  f1<-function(x, theta, a) {
    m<-theta[1]; s<-theta[2];
    a*exp(-0.5*((x-m)/s)^2)
  }
```

```{r fitf1}

fitf1<- function(subx, m=20, a=1, s=0.08, xshift=100){
f1<-function(x, theta, a) {
  m<-theta[1]; s<-theta[2];
  ifelse(s<0,-1,1)*a*exp(-0.5*((x-m)/s)^2)
}
for(m in 20:100){
fit1<-try(nls(y~f1(x,c(m,s),a), data=subx, start=list(m=log(m+xshift), s=s), control = list(maxiter = 500), algorithm="port", lower=c(0,0.03)), silent=TRUE)
if(!inherits(fit1, "try-error")) break
}
return(fit1)
}

signx <- function(x) return(ifelse(x<0,-1,1))

getcis <- function(fit.best, subx, m=20, s=0.2, sig=0.05, level=0.05, xshift=100){
  sig <- max(summary(fit.best)$sigma, sig)
  err.best <- residuals(fit.best)
  n <- length(err.best)
  val=c()
aval <- seq(.5, 10*coef(fit.best)[3],0.02)
for(a in aval){
  fit <- fitf1(subx, a=a, m=m, s=s, xshift=xshift)
  err <- residuals(fit)
  rss=sum(err^2, na.rm=TRUE)
  Fval <- (rss-sum(err.best^2, na.rm=TRUE))/sig^2
  tauval <- signx(a-coef(fit.best)[3])*sqrt(Fval)
  if(!is.na(tauval) && tauval>3 && tauval<5) break #catch bad fits with < 5
  val <- rbind(val, c(rss=rss, tau=tauval,
                      coef(fit),a=a))
}
val <- val[val[,"tau.a"]> -5 & val[,"tau.a"]< 5,]
mina <- max(which(val[,"tau.a"]<qt(level/2,n-3)),1)
maxa <- min(which(val[,"tau.a"]>qt(1-level/2,n-3)),nrow(val))
return(cbind(val[mina,c("m", "s", "a")], val[maxa,c("m", "s", "a")]))
}
```

```{r getfit}
# Get the fit
getfit <- function(x, posmin=100, maxh=200, xshift=100, fun="f2", s.fix=0.08, sig=0.05){
  xshift <- 100
  x$new.cases.smooth <- stats::filter(x$new.cases, rep(1/3,3))
day1 <- min(which(x$positive>posmin))
x$day <- 1:nrow(x) - day1 + 1

subx <- subset(x, positive>posmin)
subx$day <- subx$day+xshift
subx$x <- log(subx$day)
subx$y <- subx$new.cases.smooth*subx$day
maxy <- max(subx$y, na.rm=TRUE)
subx$y <- subx$y/maxy
for(s in c(.1,1,seq(0.2,3,0.5))){
  for(m in seq(20,100,10)+xshift){
  if(fun=="f2") fit<-try(nls(y~f2(x,c(m,s,a)), data=subx, start=list(m=log(m), s=s, a=max(subx$y, na.rm=TRUE)), control = list(maxiter = 500)), silent=TRUE)
  if(fun=="f4") fit<-try(nls(y~f4(x,c(m,a), s.fix), data=subx, start=list(m=log(m), a=max(subx$y, na.rm=TRUE)), control = list(maxiter = 500)), silent=TRUE)
  if(!inherits(fit, "try-error")) break()
  }
  if(!inherits(fit, "try-error")) break()
}
if(inherits(fit, "try-error")) return(list(x=x, pred=NULL, fit=fit))
x$fitted <-c(rep(NA, day1-1), predict(fit, newdata=subx)*maxy/subx$day)

pred <- data.frame(day=((nrow(x)+1):maxh)-day1+1+xshift, date=x$date[1]+nrow(x):(maxh-1))
pred$x <- log(pred$day)
pred$pred <- predict(fit, newdata=pred)*maxy/pred$day

cm1=NA; cm2=NA
confval1 <- try(confint(fit, level=0.95), silent=TRUE)
if(inherits(confval1, "try-error") || summary(fit)$sigma<0.03 || any(is.na(confval1)) ){ 
  confval <- try(getcis(fit.best=fit, subx=subx, level=0.05, xshift=xshift, sig=sig))
  if(!inherits(confval1, "try-error") && !inherits(confval, "try-error") && !any(any(is.na(confval1[,1])))) confval[,1] <- confval1[,1]
  if(!inherits(confval1, "try-error") && !inherits(confval, "try-error") && !any(any(is.na(confval1[,2])))) confval[,2] <- confval1[,2]
  }else{ confval <- confval1 }

if(!inherits(confval, "try-error")){
  if(fun=="f2"){
    cm1 <- sum(f2(log(pred$day), confval[,1])*maxy/pred$day)
  cm2 <- sum(f2(log(pred$day), confval[,2])*maxy/pred$day)
  pred$pred.low <- f2(log(pred$day), confval[,1])*maxy/pred$day
  pred$pred.high <- f2(log(pred$day), confval[,2])*maxy/pred$day
   x$fitted.low <-c(rep(NA, day1-1), f2(subx$x, confval[,1])*maxy/subx$day)
  x$fitted.high <-c(rep(NA, day1-1), f2(subx$x, confval[,2])*maxy/subx$day)
 }else{
    cm1 <- sum(f4(log(pred$day), confval[,1], s.fix)*maxy/pred$day)
  cm2 <- sum(f4(log(pred$day), confval[,2], s.fix)*maxy/pred$day)
  pred$pred.low <- f4(log(pred$day), confval[,1], s.fix)*maxy/pred$day
  pred$pred.high <- f4(log(pred$day), confval[,2], s.fix)*maxy/pred$day
  x$fitted.low <-c(rep(NA, day1-1), f4(subx$x, confval[,1], s.fix)*maxy/subx$day)
  x$fitted.high <-c(rep(NA, day1-1), f4(subx$x, confval[,2], s.fix)*maxy/subx$day)
  }

}

return(list(x=x, subx=subx, pred=pred, fit=fit, confval=confval, cm=sort(c(cm1, cm2))))
}
```

```{r myfun}
myfun <- function(data, reg, posmin=100, maxh=100, xshift=100, bad.reg=NULL, fun="f2", s.fix=0.08, sig=0.05){
b<-subset(data, region==reg)
if(max(b$positive)<1000) return()
day1 <- min(which(b$positive>posmin))

b$new.cases <- c(NA, diff(b$positive))
if(reg=="MI") b$new.cases[b$new.cases==5269]=600 #hack to fix MI for now
if(reg=="France") b$new.cases[b$new.cases==25615]=7000 #hack to fix France for now
cfr <- mean(b$death[(nrow(b)-5):nrow(b)]/b$positive[(nrow(b)-5-7):(nrow(b)-7)], na.rm=TRUE)

fit <- getfit(b, posmin=posmin, maxh=maxh, xshift=xshift,
              fun=fun, s.fix=s.fix, sig=sig)
if(inherits(fit$fit, "try-error")) return()

# updated with fitted
b <- fit$x
pred <- fit$pred

p <- ggplot(b, aes(x = date, y = new.cases.smooth)) + geom_point() + 
  geom_point(data=subset(b, positive>posmin), col="blue") +
  geom_line(aes(x=date, y=fitted), data=b) +
  geom_line(aes(x=date, y=pred), data=pred, color="red") +
  ggtitle(reg)

  npos <- max(b$positive, na.rm=TRUE)+sum(pred$pred, na.rm=TRUE)
  ndeaths.p <- max(b$death, na.rm=TRUE)+
    sum(b$new.cases[(nrow(b)-7):nrow(b)])*cfr
  ndeaths <- ndeaths.p +
    sum(pred$pred, na.rm=TRUE)*cfr

  if(!inherits(fit$confval, "try-error") && !reg%in%bad.reg){
  bm <- 1.05*max(b$new.cases.smooth, pred$pred, pred$pred.high, na.rm=TRUE)
  #mode of log normal is 
  mode.lims <- sort(round(exp(fit$confval[1,]-fit$confval[2,]^2)))
  df <- data.frame(x=b$date[1]+day1+mode.lims-xshift-1, y=c(bm,bm))
  #p <- p + geom_line(data=df, aes(x=x, y=y), size=5, color="grey")
  if(fun=="f2") cfs <- coef(fit$fit)
  if(fun=="f4") cfs <- c(coef(fit$fit)[1], s.fix, coef(fit$fit)[2])
  p <- p +
  ggtitle(paste(reg, "\nPoint estimates: Positives =",
                round(npos),
                "Deaths =", round(ndeaths), 
                "CFR =",
                round(100*cfr,digits=2),"\n",
                "Deaths low", 
                round(ndeaths.p+fit$cm[1]*cfr), 
                " to Deaths high", 
                round(ndeaths.p+fit$cm[2]*cfr), "\n",
                "s = ", round(cfs[2],3), "sig = ", round(summary(fit$fit)$sigma,3), 
                "sig.ci =", round(max(summary(fit$fit)$sigma, sig),3)))
  fit$pred$new.cases.smooth <- fit$pred$pred
  p <- p +
    geom_ribbon(data=fit$pred, aes(x=date, ymin = pred.low, ymax = pred.high), fill = "pink") +
    geom_line(data=fit$pred, aes(x=date, y=pred.low), linetype="dashed", color="red") +
    geom_line(data=fit$pred, aes(x=date, y=pred.high), linetype="dashed", color="red") + 
    geom_line(data=fit$pred, aes(x=date, y=pred), color="red")
  p <- p + annotate("text", x=min(b$date), y=bm, label=paste("\nDeaths to date\n", max(b$death, na.rm=TRUE)), hjust=0)


}else{
  cfs <- coef(fit$fit)
  p <- p +
  ggtitle(paste(reg, "\nPoint estimates: Positives =", round(npos),
                "Deaths =", round(ndeaths), "CFR =",
                round(100*cfr,digits=2), "\n",
                "s = ", round(cfs[2],3), "sig = ", round(summary(fit$fit)$sigma,3)))
}
  
return(list(p=p, fit=fit$fit, confint=fit$confval))
}
```

## Lombardia

Lombardia is my case study area and I will use the $\sigma$ for this region as the $\sigma$ parameter for the curves in other areas.

```{r Lomb-forecast}
p <- myfun(italy, "Lombardia")
if(inherits(p, "list")) plot(p$p)
s <- coef(p$fit)[2]
```

## Hubei China

```{r China-forecast}
for(i in c("Hubei China")){
  p <- myfun(world, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```

## A few European Countries

```{r  Europe-forecast}
for(i in c("Austria", "Belgium", "Czechia", "Denmark",
           "France", "Germany", 
           "Ireland", "Italy", 
           "Norway", "Netherlands", 
           "Poland", 
           "Spain",  "Sweden", 
           "United Kingdom")){
  p <- myfun(world, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```


```{r  Asia-forecast1}
for(i in c("Japan", "India", "Pakistan")){
  p <- myfun(world, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```

## North America

```{r NAmer-forecast1}
for(i in c("US", "Canada")){
  p <- myfun(world, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```
```{r Mex-forecast}
for(i in c("Mexico")){
  p <- myfun(world, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```

## South America

```{r SAmer-forecast}
for(i in c("Brazil", "Chile")){
  p <- myfun(world, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```


## US States

Only states with a lockdown are shown. There is no data yet on countries that do not try to stop the spread with a lockdown. The residual variance (difference between the line and data) is estimated from the fit with a minimum value of 0.05 (take from the average residual variance during the upswing part of an epidemic).


```{r states-forecast1}
for(i in c("NY", "NJ", "MA", "CT", "DE", "PA", "MD", "MI", "WI", "OH", "IL", "IN", "WA", "CA", "OR", "CO")){
  p <- myfun(states, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```

More states with later lockdowns or none.

```{r states-forecast2}
for(i in c("FL", "TN", "MO", "IA", "NH", "TX","OK", "GA", "VA", "WV", "UT", "AL", "MS")){
  p <- myfun(states, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```

Louisiana looks weird.

```{r LAforecast}
for(i in c("LA")){
  p <- myfun(states, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```