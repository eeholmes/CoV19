---
title: "Forecasts"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
```

```{r, message=FALSE, warning=FALSE, include=FALSE}
library(CoV19)
library(ggplot2)
library(gridExtra)
```

These are forecast by fitting a log-normal shape curve the new positive cases and estimating deaths using the 7-lag CFR.  The 95% confidence intervals on the forecasts are shown. 

These are just toy forecasts to try to understand the behavior of statistical forecasts using only a log-normal fit to new cases.  This is somewhat similar to the strategy used in the [UW model](https://covid19.healthdata.org/) except they fit to deaths and I am fitting to a 3-day average of reported positives.

These are just experiments to understand the nature of these kind of fits.  Don't put any stock whatsoever into these 'forecasts'. One thing I've noticed is that, the fitting algorithm seems to like to put the peak at the end of the data. Perhaps that is true or perhaps this approach is biased that way. I am fitting a lognormal curve and that is a very specific curve shape. That curve may be imposing too much 'information' when there is no real information in the data about the location of the peak.

```{r thenormfuncs}
# estimate mu, sigma and scaling
  f2<-function(x, theta) {
    m<-theta[1]; s<-theta[2]; a<-theta[3];
    a*exp(-0.5*((x-m)/s)^2)
  }
  f2<-function(x, theta) {
    m<-theta[1]; s<-theta[2]; a<-theta[3];
    a*exp(-0.5*((x-m)/s)^2)
  }
# fix m
  f3<-function(x, theta, m) {
    s<-theta[1]; a<-theta[2];
    a*exp(-0.5*((x-m)/s)^2)
  }
# fix s
  f4<-function(x, theta, s) {
    m<-theta[1]; a<-theta[2];
    a*exp(-0.5*((x-m)/s)^2)
  }
```

```{r}
# Get the fit
getfit <- function(x, posmin=100, maxh=200, xshift=100, fun="f2", s.fix=0.08){
  xshift <- 100
  x$new.cases <- c(NA, diff(x$positive))
  x$new.cases.smooth <- stats::filter(x$new.cases, rep(1/3,3))
day1 <- min(which(x$positive>posmin))
x$day <- 1:nrow(x) - day1 + 1

subx <- subset(x, positive>posmin)
subx$day <- subx$day+xshift
subx$x <- log(subx$day)
subx$y <- subx$new.cases.smooth*subx$day
maxy <- max(subx$y, na.rm=TRUE)
subx$y <- subx$y/maxy
for(s in c(.1,1,seq(0.2,3,0.5))){
  for(m in seq(20,100,10)+xshift){
  if(fun=="f2") fit<-try(nls(y~f2(x,c(m,s,a)), data=subx, start=list(m=log(m), s=s, a=max(subx$y, na.rm=TRUE)), control = list(maxiter = 500)), silent=TRUE)
  if(fun=="f4") fit<-try(nls(y~f4(x,c(m,a), s.fix), data=subx, start=list(m=log(m), a=max(subx$y, na.rm=TRUE)), control = list(maxiter = 500)), silent=TRUE)
  if(!inherits(fit, "try-error")) break()
  }
  if(!inherits(fit, "try-error")) break()
}
if(inherits(fit, "try-error")) return(list(x=x, pred=NULL, fit=fit))
x$fitted <-c(rep(NA, day1-1), predict(fit, newdata=subx)*maxy/subx$day)

pred <- data.frame(day=((nrow(x)+1):maxh)-day1+1+xshift, date=x$date[1]+nrow(x):(maxh-1))
pred$x <- log(pred$day)
pred$pred <- predict(fit, newdata=pred)*maxy/pred$day

cm1=NA; cm2=NA
confval <- try(confint(fit, level=0.75), silent=TRUE)
# if(inherits(confval, "try-error")){ 
#   confval <- try(confint(fit, parm=c("m"), level=0.75), silent=TRUE)
#   if(!inherits(confval, "try-error")){
#     cfs <- coef(fit)
#     fit1<-try(nls(y~f3(x,c(s,a),confval[1]), data=subx, start=list(s=cfs[2], a=cfs[3])), silent=TRUE)
#     fit2<-try(nls(y~f3(x,c(s,a),confval[2]), data=subx, start=list(s=cfs[2], a=cfs[3])), silent=TRUE)
#     if(!inherits(fit1, "try-error") & !inherits(fit2, "try-error")){
#   confval <- rbind(confval, 
#                    s=c(coef(fit1)[1], coef(fit2)[1]),
#                    a=c(coef(fit1)[2], coef(fit2)[2]))
#   }else{ class(confval) <- "try-error" }
#   }
# }

if(!inherits(confval, "try-error")){
  if(fun=="f2"){
    cm1 <- sum(f2(log(pred$day), confval[,1])*maxy/pred$day)
  cm2 <- sum(f2(log(pred$day), confval[,2])*maxy/pred$day)
  pred$pred.low <- f2(log(pred$day), confval[,1])*maxy/pred$day
  pred$pred.high <- f2(log(pred$day), confval[,2])*maxy/pred$day
   x$fitted.low <-c(rep(NA, day1-1), f2(subx$x, confval[,1])*maxy/subx$day)
  x$fitted.high <-c(rep(NA, day1-1), f2(subx$x, confval[,2])*maxy/subx$day)
 }else{
    cm1 <- sum(f4(log(pred$day), confval[,1], s.fix)*maxy/pred$day)
  cm2 <- sum(f4(log(pred$day), confval[,2], s.fix)*maxy/pred$day)
  pred$pred.low <- f4(log(pred$day), confval[,1], s.fix)*maxy/pred$day
  pred$pred.high <- f4(log(pred$day), confval[,2], s.fix)*maxy/pred$day
  x$fitted.low <-c(rep(NA, day1-1), f4(subx$x, confval[,1], s.fix)*maxy/subx$day)
  x$fitted.high <-c(rep(NA, day1-1), f4(subx$x, confval[,2], s.fix)*maxy/subx$day)
  }

}

return(list(x=x, pred=pred, fit=fit, confval=confval, cm=sort(c(cm1, cm2))))
}
```

```{r thefunction}
myfun <- function(data, reg, posmin=100, maxh=100, xshift=100, bad.reg=NULL, fun="f2", s.fix=0.08){
b<-subset(data, region==reg)
if(max(b$positive)<1000) return()
day1 <- min(which(b$positive>posmin))

b$new.cases <- c(NA, diff(b$positive))
cfr <- mean(b$death[(nrow(b)-5):nrow(b)]/b$positive[(nrow(b)-5-7):(nrow(b)-7)], na.rm=TRUE)

fit <- getfit(b, posmin=posmin, maxh=maxh, xshift=xshift,
              fun=fun, s.fix=s.fix)
if(inherits(fit$fit, "try-error")) return()

# updated with fitted
b <- fit$x
pred <- fit$pred

p <- ggplot(b, aes(x = date, y = new.cases.smooth)) + geom_point() + 
  geom_point(data=subset(b, positive>posmin), col="blue") +
  geom_line(aes(x=date, y=fitted), data=b) +
  geom_line(aes(x=date, y=pred), data=pred, color="red") +
  ggtitle(reg)

  npos <- max(b$positive, na.rm=TRUE)+sum(pred$pred, na.rm=TRUE)
  ndeaths.p <- max(b$death, na.rm=TRUE)+
    sum(b$new.cases[(nrow(b)-7):nrow(b)])*cfr
  ndeaths <- ndeaths.p +
    sum(pred$pred, na.rm=TRUE)*cfr

  if(!inherits(fit$confval, "try-error") & !reg%in%bad.reg){
  bm <- 1.05*max(b$new.cases, pred$pred, na.rm=TRUE)
  #mode of log normal is 
  mode.lims <- sort(round(exp(fit$confval[1,]-fit$confval[2,]^2)))
  df <- data.frame(x=b$date[1]+day1+mode.lims-xshift-1, y=c(bm,bm))
  #p <- p + geom_line(data=df, aes(x=x, y=y), size=5, color="grey")
  if(fun=="f2") cfs <- coef(fit$fit)
  if(fun=="f4") cfs <- c(coef(fit$fit)[1], s.fix, coef(fit$fit)[2])
  p <- p +
  ggtitle(paste(reg, "\nPoint estimates: Positives =",
                round(npos),
                "Deaths =", round(ndeaths), 
                "CFR =",
                round(100*cfr,digits=2),"\n",
                "Deaths low", 
                round(ndeaths.p+fit$cm[1]*cfr), 
                " to Deaths high", 
                round(ndeaths.p+fit$cm[2]*cfr), "\n",
                "s = ", cfs[2]))
  fit$pred$y <- fit$pred$pred
  p <- p +
    geom_ribbon(data=fit$pred, aes(x=date, y=pred, ymin = pred.low, ymax = pred.high), fill = "pink") +
    geom_line(data=fit$pred, aes(x=date, y=pred.low), linetype="dashed", color="red") +
    geom_line(data=fit$pred, aes(x=date, y=pred.high), linetype="dashed", color="red") + 
    geom_line(data=fit$pred, aes(x=date, y=pred), color="red")


}else{
  p <- p +
  ggtitle(paste(reg, "\nPoint estimates: Positives =", round(npos),
                "Deaths =", round(ndeaths), "CFR =",
                round(100*cfr,digits=2), "\n",
                "s = ", coef(fit$fit)[2]))
}
  
return(list(p=p, fit=fit$fit))
}
```

## Lombardia

Lombardia is my case study area and I will use the $\sigma$ for this region as the $\sigma$ parameter for the curves in other areas.

```{r}
p <- myfun(italy, "Lombardia")
if(inherits(p, "list")) plot(p$p)
s <- coef(p$fit)[2]
```

## Hubei China

```{r}
for(i in c("Hubei China")){
  p <- myfun(world, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```

## A few European Countries

```{r}
for(i in c("Austria", "Belgium", "Czechia", 
           "France", "Germany", 
           "Ireland", "Italy", 
           "Norway", "Netherlands", 
           "Poland", 
           "Spain",  "Sweden", 
           "United Kingdom")){
  p <- myfun(world, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
  p <- myfun(world, "Sweden", posmin=2, maxh=150)
  if(inherits(p, "list")) plot(p$p)
```


```{r, eval=FALSE}
for(i in c("Japan", "India", "Pakistan", "Hubei China")){
  p <- myfun(subset(world, date>"2020-03-01"), i, posmin=100, maxh=150, fun="f4", s.fix=s)
  if(inherits(p, "list")) plot(p$p)
}
```

## North America

For North America, I used the $\sigma$ for Lombardia to produce the estimates.

```{r}
for(i in c("US", "Canada")){
  p <- myfun(world, i, posmin=100, maxh=150, fun="f4", s.fix=s)
  if(inherits(p, "list")) plot(p$p)
}
```



## US States

Only states with a lockdown are shown and with a $\sigma$ of that in Lombardia. There is no data yet on countries that do not try to stop the spread with a lockdown.

The ranges here are really narrow because I fixed the $\sigma$ to that in Lombardia, so only variation in $\mu$ and $\alpha$ are included.

```{r}
for(i in c("NY", "NJ", "MA", "CT", "DE", "PA", "MD", "MI", "OH", "IL", "IN", "WA", "CA", "OR", "CO", "LA")){
  p <- myfun(states, i, posmin=10, maxh=150, fun="f4", s.fix=s)
  if(inherits(p, "list")) plot(p$p)
}
```
