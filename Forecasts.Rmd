---
title: "Forecasts"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message=FALSE)
```

```{r, message=FALSE, warning=FALSE, include=FALSE}
library(CoV19)
library(ggplot2)
library(gridExtra)
```

These are forecast by fitting a log-normal shape curve the new positive cases and estimating deaths using the 7-lag CFR.  The 95% confidence intervals on the forecasts are shown. 

These are just toy forecasts to try to understand the behavior of statistical forecasts using only a log-normal fit to new cases.  This is similar to the strategy used in the UW model.  

I found that the fits are sensitive to noisy data and I used a 3-day average of new cases to try to deal with this.  In many cases the non-linear fitting function I used (`nls`) was not able to estimate a curve or if it could estimate the curve, it could not estimate the confidence intervals on the parameters. When it did estimate, it seems to like to put the peak at the end of the data. Perhaps that is true or perhaps this approach is biased that way.

```{r thenormfuncs}
# estimate mu, sigma and scaling
  f2<-function(x, theta) {
    m<-theta[1]; s<-theta[2]; a<-theta[3];
    a*exp(-0.5*((x-m)/s)^2)
  }
# fix mu
  f3<-function(x, theta, m) {
    s<-theta[1]; a<-theta[2];
    a*exp(-0.5*((x-m)/s)^2)
  }
```

```{r}
# Get the fit
getfit <- function(x, posmin=100, maxh=200, xshift=100){
  xshift <- 100
  x$new.cases <- c(NA, diff(x$positive))
  x$new.cases.smooth <- stats::filter(x$new.cases, c(1/3,1/3,1/3))
day1 <- min(which(x$positive>posmin))
x$day <- 1:nrow(x) - day1 + 1

subx <- subset(x, positive>posmin)
subx$day <- subx$day+xshift
subx$x <- log(subx$day)
subx$y <- subx$new.cases.smooth*subx$day
maxy <- max(subx$y, na.rm=TRUE)
subx$y <- subx$y/maxy
for(s in c(1,2,seq(0.2,3,0.5))){
  for(m in seq(20,100,10)+xshift){
  fit<-try(nls(y~f2(x,c(m,s,a)), data=subx, start=list(m=log(m), s=s, a=max(subx$y, na.rm=TRUE))), silent=TRUE)
  if(!inherits(fit, "try-error")) break()
  }
  if(!inherits(fit, "try-error")) break()
}
if(inherits(fit, "try-error")) return(list(x=x, pred=NULL, fit=fit))
x$fitted <-c(rep(NA, day1-1), predict(fit, newdata=subx)*maxy/subx$day)

pred <- data.frame(day=((nrow(x)+1):maxh)-day1+1+xshift, date=x$date[1]+nrow(x):(maxh-1))
pred$x <- log(pred$day)
pred$pred <- predict(fit, newdata=pred)*maxy/pred$day

cm1=NA; cm2=NA
confval <- try(confint(fit, level=0.75), silent=TRUE)
if(inherits(confval, "try-error")){ 
  confval <- try(confint(fit, parm=c("m"), level=0.75), silent=TRUE)
  if(!inherits(confval, "try-error")){
    cfs <- coef(fit)
    fit1<-try(nls(y~f3(x,c(s,a),confval[1]), data=subx, start=list(s=cfs[2], a=cfs[3])), silent=TRUE)
    fit2<-try(nls(y~f3(x,c(s,a),confval[2]), data=subx, start=list(s=cfs[2], a=cfs[3])), silent=TRUE)
    if(!inherits(fit1, "try-error") & !inherits(fit2, "try-error")){
  confval <- rbind(confval, 
                   s=c(coef(fit1)[1], coef(fit2)[1]),
                   a=c(coef(fit1)[2], coef(fit2)[2]))
  }else{ class(confval) <- "try-error" }
  }
}

if(!inherits(confval, "try-error")){
  cm1 <- sum(f2(log(pred$day), confval[,1])*maxy/pred$day)
  cm2 <- sum(f2(log(pred$day), confval[,2])*maxy/pred$day)
  pred$pred.low <- f2(log(pred$day), confval[,1])*maxy/pred$day
  pred$pred.high <- f2(log(pred$day), confval[,2])*maxy/pred$day
  x$fitted.low <-c(rep(NA, day1-1), f2(subx$x, confval[,1])*maxy/subx$day)
  x$fitted.high <-c(rep(NA, day1-1), f2(subx$x, confval[,2])*maxy/subx$day)

}

return(list(x=x, pred=pred, fit=fit, confval=confval, cm=sort(c(cm1, cm2))))
}
```

```{r thefunction}
myfun <- function(data, reg, posmin=100, maxh=100, xshift=100, bad.reg=NULL){
b<-subset(data, region==reg)
if(max(b$positive)<1000) return()
day1 <- min(which(b$positive>posmin))

b$new.cases <- c(NA, diff(b$positive))
cfr <- mean(b$death[(nrow(b)-5):nrow(b)]/b$positive[(nrow(b)-5-7):(nrow(b)-7)], na.rm=TRUE)

fit <- getfit(b, posmin=posmin, maxh=maxh, xshift=xshift)
if(inherits(fit$fit, "try-error")) return()

# updated with fitted
b <- fit$x
pred <- fit$pred

p <- ggplot(b, aes(x = date, y = new.cases)) + geom_point() + 
  geom_point(data=subset(b, positive>posmin), col="blue") +
  geom_line(aes(x=date, y=fitted), data=b) +
  geom_line(aes(x=date, y=pred), data=pred, color="red") +
  ggtitle(reg)

  npos <- max(b$positive, na.rm=TRUE)+sum(pred$pred, na.rm=TRUE)
  ndeaths.p <- max(b$death, na.rm=TRUE)+
    sum(b$new.cases[(nrow(b)-7):nrow(b)])*cfr
  ndeaths <- ndeaths.p +
    sum(pred$pred, na.rm=TRUE)*cfr

  if(!inherits(fit$confval, "try-error") & !reg%in%bad.reg){
  bm <- 1.05*max(b$new.cases, pred$pred, na.rm=TRUE)
  #mode of log normal is 
  mode.lims <- sort(round(exp(fit$confval[1,]-fit$confval[2,]^2)))
  df <- data.frame(x=b$date[1]+day1+mode.lims-xshift-1, y=c(bm,bm))
  #p <- p + geom_line(data=df, aes(x=x, y=y), size=5, color="grey")
  p <- p +
  ggtitle(paste(reg, "\nPoint estimates: Positives =",
                round(npos),
                "Deaths =", round(ndeaths), 
                "CFR =",
                round(100*cfr,digits=2),"\n",
                "Deaths low", round(ndeaths.p+fit$cm[1]*cfr), " to Deaths high", round(ndeaths.p+fit$cm[2]*cfr)))
  fit$pred$y <- fit$pred$pred
  p <- p +
    geom_ribbon(data=fit$pred, aes(x=date, y=pred, ymin = pred.low, ymax = pred.high), fill = "pink") +
    geom_line(data=fit$pred, aes(x=date, y=pred.low), linetype="dashed", color="red") +
    geom_line(data=fit$pred, aes(x=date, y=pred.high), linetype="dashed", color="red") + 
    geom_line(data=fit$pred, aes(x=date, y=pred), color="red")


}else{
  p <- p +
  ggtitle(paste(reg, "\nPoint estimates: Positives =", round(npos),
                "Deaths =", round(ndeaths), "CFR =",
                round(100*cfr,digits=2)))
}
  
return(list(p=p, fit=fit$fit))
}
```

## A few European Countries

```{r}
for(i in c("Italy", "France", "Spain", "United Kingdom", "Sweden",
           "Germany", "Norway", "Belgium", "Netherlands", "Austria", "Czechia", "Poland")){
  p <- myfun(world, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```


```{r, eval=FALSE}
for(i in c("Japan", "India", "Pakistan")){
  p <- myfun(subset(world, date>"2020-03-01"), i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```

## North America

```{r}
for(i in c("US", "Mexico", "Canada")){
  p <- myfun(world, i, posmin=100, maxh=150)
  if(inherits(p, "list")) plot(p$p)
}
```



## US States

Only states where the location of the peak could be estimated are shown.

```{r}
for(i in state.abb){
  p <- myfun(states, i, posmin=100, maxh=150, bad.reg=c("UT","TN","PA"))
  if(inherits(p, "list")) plot(p$p)
}
```
